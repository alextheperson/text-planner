import Buffer from './buffer';
import { parseExpression, OUTPUT_TYPE, Command, CommandRegistry } from './commands';
import { BindableInt, BindableString, STATIC_TYPES } from './dataType';
import { keymap } from './keymap';
import ModeManager, { CommandMode, Modes } from './modes';
import { TextBox } from './shapes/textbox';

class ConsoleLine {
	message: string;
	type: OUTPUT_TYPE;
	input: boolean;
	constructor(message: string, type: OUTPUT_TYPE, input: boolean) {
		this.message = message;
		this.type = type;
		this.input = input;
	}
}

class CommandConsole {
	/**
	 * The number of previous commands that the console stores.
	 */
	historyLength = 5;
	/**
	 * The number of lines to display onscreen. Also determines the height.
	 */
	historyDisplayLines = 5;
	/**
	 * The horizontal position of the cursor (in characters)
	 */
	cursorPosition = 0;
	/**
	 * A list of previously run commands. May or may not be valid.
	 */
	private commandHistory: string[] = [];
	/**
	 * The lines that the console is currently displaying. Index 0 is at the bottom, with increasing indices going up.
	 */
	private lines: ConsoleLine[] = [];
	/**
	 * Where in the list of previous commands the user is on. When they make an edit, this is set to 0.
	 */
	private historyPosition = 0;
	/**
	 * A list of generated by autofill options
	 */
	private currentAutofill: string[] = [];
	/**
	 * What row of the autofill options the user has selected
	 */
	private autofillPosition = 0;

	/**
	 * Renders the console in its current state.
	 * @param width The width of the screen. Determines the width of the console.
	 * @returns A buffer with the rendered console.
	 */
	render(width: number): Buffer {
		const buffer = new Buffer(width, this.historyDisplayLines, '');

		let modeString = `|-????-|`;
		if (ModeManager.mode === Modes.VIEW_MODE) {
			modeString = `|-VIEW-|`;
		} else if (ModeManager.mode === Modes.EDIT_MODE) {
			modeString = `|-EDIT-|`;
		} else if (ModeManager.mode === Modes.MOVE_MODE) {
			modeString = `|-MOVE-|`;
		} else if (ModeManager.mode === Modes.COMMAND) {
			modeString = `|-CMND-|`;
		}

		// const permString = this.writable ? '' : `Readonly`;

		buffer.composite(
			0,
			0,
			new TextBox(
				new BindableInt(0),
				new BindableInt(0),
				new BindableString(modeString),
				''
			).render('')
		); // Display the command prompt
		for (let i = 0; i < this.lines.length; i++) {
			const currentLine = this.lines[i];
			buffer.composite(
				8,
				buffer.height - (i + 1),
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(currentLine.input ? '<|' : '|>'),
					''
				).render('')
			); // Display the command prompt
			buffer.composite(
				10,
				buffer.height - (i + 1),
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(currentLine.message),
					''
				).render(
					currentLine.type === OUTPUT_TYPE.ERROR
						? 'error'
						: currentLine.type === OUTPUT_TYPE.WARNING
						? 'warning'
						: ''
				)
			); // Display the command prompt
			if (i === 0 && ModeManager.mode === Modes.COMMAND) {
				buffer.composite(
					10 + this.cursorPosition,
					buffer.height - (i + 1),
					new TextBox(
						new BindableInt(0),
						new BindableInt(0),
						new BindableString(currentLine.message[this.cursorPosition] ?? ' '),
						''
					).render('commandCursor')
				); // Display the command prompt
			}
		}

		if (ModeManager.currentMode instanceof CommandMode && this.currentAutofill.length > 0) {
			let optionString = '';
			for (let i = 0; i < this.currentAutofill.length; i++) {
				if (this.autofillPosition === i) {
					optionString += '> ' + this.currentAutofill[i] + '\n';
				} else {
					optionString += '  ' + this.currentAutofill[i] + '\n';
				}
			}
			buffer.composite(
				this.commandHistory[0].lastIndexOf(' ') + 9,
				buffer.height - this.currentAutofill.length - 3,
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(optionString),
					''
				).render('')
			);
		}

		return buffer;
	}

	/**
	 * Adds an output line to the console.
	 * @param message
	 * @param type
	 */
	addLine(message: string, type: OUTPUT_TYPE) {
		this.lines.unshift(new ConsoleLine(message, type, false));
		this.lines = this.lines.slice(0, this.historyDisplayLines);
	}

	/**
	 * Adds a new blank input line to the console if there isn't one already.
	 */
	open() {
		if (this.lines.length !== 0 && this.lines[0].message === '' && this.lines[0].input) {
			this.lines.shift();
			this.commandHistory.shift();
		}
		this.commandHistory.unshift('');
		this.commandHistory = this.commandHistory.slice(0, this.historyLength);
		this.lines.unshift(new ConsoleLine(this.commandHistory[0], OUTPUT_TYPE.NORMAL, true));
		this.lines = this.lines.slice(0, this.historyDisplayLines);
		this.cursorPosition = 0;
	}

	/**
	 * Clears any content in the bottom row of the console, if that row in an input row.
	 */
	close() {
		if (!this.lines[0].input) {
			return;
		}
		this.lines.shift();
		this.lines.unshift(new ConsoleLine('', OUTPUT_TYPE.NORMAL, true));
	}

	/**
	 * Run a keyboard event to the console.
	 * @param key The key that is pressed
	 */
	input(key: string) {
		if (key.length === 1) {
			if (this.historyPosition !== 0) {
				this.commandHistory.unshift(this.commandHistory[this.historyPosition]);
				this.commandHistory.slice(0, this.historyLength);
				this.historyPosition = 0;
			}
			this.addChar(key, this.cursorPosition);
			this.cursorPosition = Math.min(this.cursorPosition + 1, this.commandHistory[0].length);
			if (key === '"') {
				this.addChar('"', this.cursorPosition);
			} else if (key === '(') {
				this.addChar(')', this.cursorPosition);
			}
		} else if (keymap.cancel.includes(key)) {
			this.deleteChar(this.cursorPosition);
			// this.cursorPosition -= 1;
			this.cursorPosition = Math.max(this.cursorPosition - 1, 0);
		} else if (keymap.confirm.includes(key)) {
			this.run();
		} else if (keymap.moveCursorUp.includes(key)) {
			if (this.commandHistory[0].length === 0) {
				this.historyPosition = Math.max(this.historyPosition + 1, this.commandHistory.length);
			} else {
				this.autofillPosition = Math.max(this.autofillPosition + 1, this.currentAutofill.length);
			}
		} else if (keymap.moveCursorDown.includes(key)) {
			if (this.commandHistory[0].length === 0) {
				this.historyPosition = Math.min(this.historyPosition - 1, 0);
			} else {
				this.autofillPosition = Math.min(this.autofillPosition - 1, 0);
			}
		} else if (keymap.moveCursorLeft.includes(key)) {
			this.cursorPosition = Math.max(this.cursorPosition - 1, 0);
		} else if (keymap.moveCursorRight.includes(key)) {
			this.cursorPosition = Math.min(this.cursorPosition + 1, this.commandHistory[0].length);
		}
	}

	/**
	 * Insert a character into the bottom input row (the active command)
	 * @param char Character to add
	 * @param index The index to add it at
	 */
	addChar(char: string, index: number) {
		this.commandHistory[0] =
			this.commandHistory[0].slice(0, index) + char + this.commandHistory[0].slice(index);
		if (this.lines[0].input) {
			this.lines[0].message = this.commandHistory[this.historyPosition];
		}
	}

	/**
	 * Deletes a character from the botom input row (the active command)
	 * @param index The index of the character to delete
	 */
	deleteChar(index: number) {
		this.commandHistory[0] =
			this.commandHistory[0].slice(0, Math.max(0, index - 1)) + this.commandHistory[0].slice(index);
		if (this.lines[0].input) {
			this.lines[0].message = this.commandHistory[this.historyPosition];
		}
	}

	/**
	 * Run the actively edited command (the bottom row, if it is an input row).
	 */
	run() {
		try {
			const output = parseExpression(this.commandHistory[this.historyPosition]);
			this.addLine(
				`(${STATIC_TYPES[output instanceof Command ? 'COMMAND' : output.type]}) ${
					output instanceof Command ? output.string : output.value
				}`,
				OUTPUT_TYPE.NORMAL
			);
		} catch (e) {
			this.addLine((e as Error).message, OUTPUT_TYPE.ERROR);
		}
		this.open();
	}

	/**
	 * Gets a list of values that could work in teh token that the cursor is on.
	 * @param start The currently entered command
	 * @returns A list of values for the currently edited token
	 */
	getAutofillOptions(start: string): string[] {
		let possibilities: string[] = [];
		const tokens: string[] = [];
		let currentToken = '';
		let inQuotes = false;

		for (let i = 0; i < start.length; i++) {
			currentToken += start[i];
			if (start[i] === "'" && start[i - 1] !== '\\') {
				inQuotes = !inQuotes;
			}
			if ((start[i] === ' ' && !inQuotes) || i === start.length - 1) {
				tokens.push(currentToken.trimEnd());
				currentToken = '';
			}
			if (start[i] === ' ' && i === start.length - 1) {
				tokens.push(currentToken);
			}
		}

		if (tokens.length <= 1) {
			CommandRegistry.commands.forEach((val) => {
				if (val.name.startsWith(tokens[0] ?? '')) {
					possibilities.push(val.name);
				}
			});
		} else {
			try {
				const lastToken = tokens.at(-1);
				const patterns = CommandRegistry.getPatterns(tokens[0]);

				for (let i = 0; i < (patterns?.length ?? 0); i++) {
					if (patterns !== undefined && patterns[i].pattern[tokens.length - 2] instanceof Array) {
						possibilities = possibilities.concat(
							(patterns[i].pattern[tokens.length - 2] as Array<string>).filter((val) => {
								return val.startsWith(lastToken ?? '') && !possibilities.includes(val);
							})
						);
					}
				}
			} catch {
				/* empty */
			}
		}

		return possibilities;
	}
}

export const UserConsole = new CommandConsole();
