import Buffer from './buffer';
import { parseExpression, OUTPUT_TYPE, Command, CommandRegistry } from './commands';
import { BindableInt, BindableString, STATIC_TYPES, Value } from './dataType';
import { keymap } from './keymap';
import ModeManager, { Modes } from './modes';
import { TextBox } from './shapes/textbox';

/**
 * Represents a line in the console.
 */
class ConsoleLine {
	/**
	 * The actual content of the line.
	 */
	message: string;
	/**
	 * Determines the type of message it is. Changes its color onscreen.
	 */
	type: OUTPUT_TYPE;
	/**
	 * Whether the line was typed by the user or was the output of a command.
	 */
	input: boolean;
	constructor(message: string, type: OUTPUT_TYPE, input: boolean) {
		this.message = message;
		this.type = type;
		this.input = input;
	}
}

class CommandConsole {
	/**
	 * The number of previous commands that the console stores.
	 */
	historyLength = 5;
	/**
	 * The number of lines to display onscreen. Also determines the height.
	 */
	historyDisplayLines = 5;
	/**
	 * The horizontal position of the cursor (in characters)
	 */
	cursorPosition = 0;
	/**
	 * The lines that the console is currently displaying. Index 0 is at the bottom, with increasing indices going up.
	 */
	private lines: ConsoleLine[] = [new ConsoleLine('', OUTPUT_TYPE.NORMAL, true)];
	/**
	 * Where in the list of previous commands the user is on. When they make an edit, this is set to 0.
	 */
	private historyPosition = 0;
	/**
	 * A list of generated by autofill options
	 */
	private currentAutofill: string[] = [];
	/**
	 * What row of the autofill options the user has selected
	 */
	private autofillPosition = 0;
	/**
	 * The current command split into its tokens (used for autofill)
	 */
	private currentTokens: string[] = [];

	private scrollPosition = 0;

	/**
	 * Renders the console in its current state.
	 * @param width The width of the screen. Determines the width of the console.
	 * @returns A buffer with the rendered console.
	 */
	render(width: number, height: number) {
		// debugger;
		this.scrollPosition = Math.max(this.cursorPosition + 15 - width, 0);
		console.log(this.lines);
		const buffer = new Buffer(width, height, '');

		let modeString = `|-????-|`;
		if (ModeManager.mode === Modes.VIEW_MODE) {
			modeString = `|-VIEW-|`;
		} else if (ModeManager.mode === Modes.EDIT_MODE) {
			modeString = `|-EDIT-|`;
		} else if (ModeManager.mode === Modes.MOVE_MODE) {
			modeString = `|-MOVE-|`;
		} else if (ModeManager.mode === Modes.COMMAND) {
			modeString = `|-CMND-|`;
		}

		buffer.composite(
			0,
			buffer.height - this.historyDisplayLines,
			new TextBox(
				new BindableInt(0),
				new BindableInt(0),
				new BindableString(modeString),
				''
			).render('')
		); // Display the command prompt

		buffer.composite(
			8,
			buffer.height - this.historyDisplayLines,
			new TextBox(
				new BindableInt(0),
				new BindableInt(0),
				new BindableString(this.currentLine.input ? '<|' : '|>'),
				''
			).render('')
		); // Display the command prompt
		buffer.composite(
			10,
			buffer.height - this.historyDisplayLines,
			new TextBox(
				new BindableInt(0),
				new BindableInt(0),
				new BindableString(
					this.lines
						.filter((val) => val.input)
						[this.historyPosition].message.slice(this.scrollPosition)
				),
				''
			).render(
				this.currentLine.type === OUTPUT_TYPE.ERROR
					? 'error'
					: this.currentLine.type === OUTPUT_TYPE.WARNING
					? 'warning'
					: ''
			)
		); // Display the command prompt
		buffer.composite(
			10 + this.cursorPosition - this.scrollPosition,
			buffer.height - this.historyDisplayLines,
			new TextBox(
				new BindableInt(0),
				new BindableInt(0),
				new BindableString(this.currentLine.message[this.cursorPosition] ?? ' '),
				''
			).render('commandCursor')
		); // Display the command prompt

		for (let i = 1; i < Math.min(this.lines.length, this.historyDisplayLines); i++) {
			const currentLine = this.lines[i];
			buffer.composite(
				8,
				buffer.height - (this.historyDisplayLines - i),
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(currentLine.input ? '<|' : '|>'),
					''
				).render('')
			); // Display the command prompt
			buffer.composite(
				10,
				buffer.height - (this.historyDisplayLines - i),
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(currentLine.message.slice(this.scrollPosition)),
					''
				).render(
					currentLine.type === OUTPUT_TYPE.ERROR
						? 'error'
						: currentLine.type === OUTPUT_TYPE.WARNING
						? 'warning'
						: ''
				)
			); // Display the command prompt
		}

		if (
			this.lines.length > 0 &&
			this.currentLine?.message !== undefined &&
			this.currentLine.message.length > 0
		) {
			this.currentAutofill = this.getAutofillOptions();
		} else {
			this.currentAutofill = [];
		}
		if (ModeManager.mode === Modes.COMMAND && this.currentAutofill.length > 0) {
			let optionString = '';
			for (let i = 0; i < this.currentAutofill.length; i++) {
				if (this.autofillPosition === i) {
					optionString += '> ' + this.currentAutofill[i] + '\n';
				} else {
					optionString += '  ' + this.currentAutofill[i] + '\n';
				}
			}
			buffer.composite(
				this.currentLine.message.lastIndexOf(' ') + 9,
				buffer.height - this.currentAutofill.length - this.historyDisplayLines,
				new TextBox(
					new BindableInt(0),
					new BindableInt(0),
					new BindableString(optionString),
					''
				).render('')
			);
		}

		return buffer;
	}

	/**
	 * Adds an output line to the console.
	 * @param message
	 * @param type
	 */
	addLine(message: string, type: OUTPUT_TYPE) {
		this.lines.unshift(new ConsoleLine(message, type, false));
	}

	/**
	 * Adds a new blank input line to the console if there isn't one already.
	 */
	open() {
		if (this.lines.length !== 0 && this.lines[0].message === '' && this.lines[0].input) {
			this.lines.shift();
		}
		this.lines.unshift(new ConsoleLine('', OUTPUT_TYPE.NORMAL, true));
		this.cursorPosition = 0;
	}

	/**
	 * Clears any content in the bottom row of the console, if that row in an input row.
	 */
	close() {
		this.historyPosition = 0;
		this.cursorPosition = 0;
		this.lines.shift();
		this.lines.unshift(new ConsoleLine('', OUTPUT_TYPE.NORMAL, true));
	}

	/**
	 * Run a keyboard event to the console.
	 * @param key The key that is pressed
	 */
	input(key: string) {
		if (key.length === 1) {
			// if (this.historyPosition !== 0) {
			// 	console.log(this.lines[Math.min(this.historyPosition, this.lines.length - 1)]);
			// 	this.lines.unshift(this.lines[Math.min(this.historyPosition, this.lines.length - 1)]);
			// 	this.lines.shift();
			// 	this.historyPosition = 0;
			// }
			this.addChar(key, this.cursorPosition);
			this.cursorPosition = Math.min(this.cursorPosition + 1, this.currentLine.message.length);
			if (key === '"') {
				this.addChar('"', this.cursorPosition);
			} else if (key === '(') {
				this.addChar(')', this.cursorPosition);
			}
		} else if (keymap.cancel.includes(key)) {
			this.deleteChar(this.cursorPosition);
			// this.cursorPosition -= 1;
			this.cursorPosition = Math.max(this.cursorPosition - 1, 0);
		} else if (keymap.confirm.includes(key)) {
			this.run();
			ModeManager.setMode(Modes.VIEW_MODE);
		} else if (keymap.moveCursorUp.includes(key)) {
			if (this.currentLine.message.length === 0 || this.historyPosition !== 0) {
				this.historyPosition = Math.min(
					this.historyPosition + 1,
					this.lines.filter((val) => val.input).length - 1
				);
			} else {
				this.autofillPosition = Math.max(this.autofillPosition - 1, 0);
			}
		} else if (keymap.moveCursorDown.includes(key)) {
			if (this.currentLine.message.length === 0 || this.historyPosition !== 0) {
				this.historyPosition = Math.max(this.historyPosition - 1, 0);
			} else {
				this.autofillPosition = Math.min(
					this.autofillPosition + 1,
					this.currentAutofill.length - 1
				);
			}
		} else if (keymap.moveCursorLeft.includes(key)) {
			this.cursorPosition = Math.max(this.cursorPosition - 1, 0);
		} else if (keymap.moveCursorRight.includes(key)) {
			this.cursorPosition = Math.min(this.cursorPosition + 1, this.currentLine.message.length);
		} else if (key === 'Tab') {
			this.applyAutofill();
		}
	}

	/**
	 * Insert a character into the bottom input row (the active command)
	 * @param char Character to add
	 * @param index The index to add it at
	 */
	addChar(char: string, index: number) {
		if (this.historyPosition !== 0) {
			this.lines[0] = structuredClone(this.currentLine);
			this.historyPosition = 0;
		}
		if (this.lines[0].input) {
			this.lines[0].message =
				this.lines[0].message.slice(0, index) + char + this.lines[0].message.slice(index);
		}
	}

	/**
	 * Deletes a character from the botom input row (the active command)
	 * @param index The index of the character to delete
	 */
	deleteChar(index: number) {
		if (this.historyPosition !== 0) {
			this.lines[0] = structuredClone(this.currentLine);
			this.historyPosition = 0;
		}
		if (this.lines[0].input) {
			this.lines[0].message =
				this.lines[0].message.slice(0, Math.max(0, index - 1)) + this.lines[0].message.slice(index);
		}
	}

	/**
	 * Run the actively edited command (the bottom row, if it is an input row).
	 */
	run() {
		try {
			const output = parseExpression(this.currentLine.message);
			if (this.historyPosition !== 0) {
				this.lines[0] = this.currentLine;
			}
			this.addLine(
				`(${STATIC_TYPES[output instanceof Command ? 'COMMAND' : output.type]}) ${
					output instanceof Command ? output.string : output.value
				}`,
				OUTPUT_TYPE.NORMAL
			);
		} catch (e) {
			this.addLine((e as Error).message, OUTPUT_TYPE.ERROR);
		}
		this.open();
	}

	/**
	 * Parses a string into an array of tokens.
	 * @param string The string to split
	 * @returns An array of tokens parsed from the string
	 */
	tokenizeExpression(string: string) {
		const tokens: string[] = [];
		let currentToken = '';
		let inQuotes = false;
		const expr = string.slice(1);

		for (let i = 0; i < expr.length; i++) {
			currentToken += expr[i];
			if (expr[i] === "'" && expr[i - 1] !== '\\') {
				inQuotes = !inQuotes;
			}
			if ((expr[i] === ' ' && !inQuotes) || i === expr.length - 1) {
				tokens.push(currentToken.trimEnd());
				currentToken = '';
			}
			if (expr[i] === ' ' && i === expr.length - 1) {
				tokens.push(currentToken);
			}
		}
		return tokens;
	}

	/**
	 * Gets a list of values that could work in teh token that the cursor is on.
	 * @param expr The currently entered command
	 * @returns A list of values for the currently edited token
	 */
	getAutofillOptions() {
		const start = this.currentLine.message ?? '';
		let possibilities: string[] = [];
		const tokens = this.tokenizeExpression(start);
		this.currentTokens = tokens;

		if (tokens.length <= 1) {
			CommandRegistry.commands.forEach((val) => {
				if (val.name.startsWith(tokens[0] ?? '')) {
					possibilities.push(val.name);
				}
			});
		} else {
			try {
				const lastToken = tokens.at(-1);
				const patterns = CommandRegistry.getPatterns(tokens[0]);

				for (let i = 0; i < (patterns?.length ?? 0); i++) {
					if (patterns !== undefined && patterns[i].pattern[tokens.length - 2] instanceof Array) {
						possibilities = possibilities.concat(
							(patterns[i].pattern[tokens.length - 2] as Array<string>).filter((val) => {
								return val.startsWith(lastToken ?? '') && !possibilities.includes(val);
							})
						);
					}
				}
			} catch {
				/* empty */
			}
		}

		return possibilities;
	}

	/**
	 * Gets an array of possible command overrides that could match the currently typed command.
	 * @param start The beginning of the command
	 * @returns An array of passible patterns that the command could fit
	 */
	getPatterns(start: string) {
		const possibilities: string[] = [];
		const tokens = this.tokenizeExpression(start).slice(0, -1);
		let patterns;

		try {
			patterns = CommandRegistry.getPatterns(tokens[0]);
		} catch {
			return [];
		}
		const parsedTokens = tokens
			.slice(1)
			.filter((val) => val.length > 0)
			.map((val) => parseExpression(val));

		for (let i = 0; i < patterns.length; i++) {
			let matches = true;
			for (let j = 0; j < parsedTokens.length; j++) {
				const currentToken = parsedTokens[j];
				const currentPatternPart = patterns[i].pattern[j];
				if (
					currentToken instanceof Value &&
					!(currentPatternPart instanceof Array) &&
					currentToken.type !== patterns[i].pattern[j]
				) {
					console.log(currentToken, currentPatternPart);
					matches = false;
					break;
				} else if (
					currentToken instanceof Value &&
					currentToken.type === STATIC_TYPES.STRING &&
					currentPatternPart instanceof Array &&
					!(currentPatternPart as Array<string>).includes(currentToken.value as string)
				) {
					matches = false;
					break;
				}
			}
			if (matches) {
				possibilities.push(
					':' +
						tokens[0] +
						' ' +
						patterns[i].pattern
							.map((val) => {
								if (val instanceof Array) {
									return '"' + val.join('"|"') + '"';
								} else {
									return '<' + STATIC_TYPES[val] + '>';
								}
							})
							.join(' ')
				);
			}
		}

		return possibilities;
	}

	/**
	 * Replaces the currently edited token with the selected autofill option
	 */
	applyAutofill() {
		const newToken = this.currentAutofill[this.autofillPosition];
		console.log(newToken);
		this.currentTokens.pop();
		this.currentTokens.push(newToken);
		this.currentLine.message = ':' + this.currentTokens.join(' ');
		this.cursorPosition = this.currentLine.message.length;
	}

	get currentLine() {
		return this.lines.filter((val) => val.input)[this.historyPosition];
	}
}

export const UserConsole = new CommandConsole();
